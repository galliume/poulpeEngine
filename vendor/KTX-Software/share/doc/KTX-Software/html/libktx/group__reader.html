<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libktx Reference: Reader</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ktx_logo_200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libktx Reference
   &#160;<span id="projectnumber">4.3.2</span>
   </div>
   <div id="projectbrief">Libraries and tools to create and read KTX image texture files.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__reader.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Reader</div>  </div>
</div><!--header-->
<div class="contents">

<p>Read KTX-formatted data.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga90cc33928a2dae962fb94b3fa2f6575d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga90cc33928a2dae962fb94b3fa2f6575d">ktxTexture2_TranscodeBasis</a> (<a class="el" href="structktxTexture2.html">ktxTexture2</a> *This, <a class="el" href="ktx_8h.html#a30cc58c576392303d9a5a54b57ef29b5">ktx_transcode_fmt_e</a> outputFormat, ktx_transcode_flags transcodeFlags)</td></tr>
<tr class="memdesc:ga90cc33928a2dae962fb94b3fa2f6575d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transcode a KTX2 texture with BasisLZ/ETC1S or UASTC images.  <a href="group__reader.html#ga90cc33928a2dae962fb94b3fa2f6575d">More...</a><br /></td></tr>
<tr class="separator:ga90cc33928a2dae962fb94b3fa2f6575d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8dfc7a981b69d26eab73c5405d7182b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaa8dfc7a981b69d26eab73c5405d7182b">ktxTexture_CreateFromStream</a> (<a class="el" href="structktxStream.html">ktxStream</a> *pStream, <a class="el" href="structktxTexture.html#a1cce9de12eb3974a236becfd098bd057">ktxTextureCreateFlags</a> createFlags, <a class="el" href="structktxTexture.html">ktxTexture</a> **newTex)</td></tr>
<tr class="memdesc:gaa8dfc7a981b69d26eab73c5405d7182b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a ktx1 or ktx2 texture according to the stream data.  <a href="group__reader.html#gaa8dfc7a981b69d26eab73c5405d7182b">More...</a><br /></td></tr>
<tr class="separator:gaa8dfc7a981b69d26eab73c5405d7182b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga180d93562cc6af30c61adf8f6a8fd827"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga180d93562cc6af30c61adf8f6a8fd827">ktxTexture_CreateFromStdioStream</a> (FILE *stdioStream, <a class="el" href="structktxTexture.html#a1cce9de12eb3974a236becfd098bd057">ktxTextureCreateFlags</a> createFlags, <a class="el" href="structktxTexture.html">ktxTexture</a> **newTex)</td></tr>
<tr class="memdesc:ga180d93562cc6af30c61adf8f6a8fd827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> or <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> from a stdio stream according to the stream data.  <a href="group__reader.html#ga180d93562cc6af30c61adf8f6a8fd827">More...</a><br /></td></tr>
<tr class="separator:ga180d93562cc6af30c61adf8f6a8fd827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57a1ce0d3f2d66439463160d6ce9d2d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga57a1ce0d3f2d66439463160d6ce9d2d0">ktxTexture_CreateFromNamedFile</a> (const char *const filename, <a class="el" href="structktxTexture.html#a1cce9de12eb3974a236becfd098bd057">ktxTextureCreateFlags</a> createFlags, <a class="el" href="structktxTexture.html">ktxTexture</a> **newTex)</td></tr>
<tr class="memdesc:ga57a1ce0d3f2d66439463160d6ce9d2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> or <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> from a named KTX file according to the file contents.  <a href="group__reader.html#ga57a1ce0d3f2d66439463160d6ce9d2d0">More...</a><br /></td></tr>
<tr class="separator:ga57a1ce0d3f2d66439463160d6ce9d2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1e401967a687b40cdf7bba11e72c2b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaf1e401967a687b40cdf7bba11e72c2b4">ktxTexture_CreateFromMemory</a> (const ktx_uint8_t *bytes, ktx_size_t size, <a class="el" href="structktxTexture.html#a1cce9de12eb3974a236becfd098bd057">ktxTextureCreateFlags</a> createFlags, <a class="el" href="structktxTexture.html">ktxTexture</a> **newTex)</td></tr>
<tr class="memdesc:gaf1e401967a687b40cdf7bba11e72c2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> or <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> from KTX-formatted data in memory according to the data contents.  <a href="group__reader.html#gaf1e401967a687b40cdf7bba11e72c2b4">More...</a><br /></td></tr>
<tr class="separator:gaf1e401967a687b40cdf7bba11e72c2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace44d98fa78b94c282016e7cf8a88b7e"><td class="memItemLeft" align="right" valign="top">ktx_uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gace44d98fa78b94c282016e7cf8a88b7e">ktxTexture_GetData</a> (<a class="el" href="structktxTexture.html">ktxTexture</a> *This)</td></tr>
<tr class="memdesc:gace44d98fa78b94c282016e7cf8a88b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the texture image data.  <a href="group__reader.html#gace44d98fa78b94c282016e7cf8a88b7e">More...</a><br /></td></tr>
<tr class="separator:gace44d98fa78b94c282016e7cf8a88b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga553c3438e75628c6d7e2280989e539c4"><td class="memItemLeft" align="right" valign="top">ktx_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga553c3438e75628c6d7e2280989e539c4">ktxTexture_GetDataSize</a> (<a class="el" href="structktxTexture.html">ktxTexture</a> *This)</td></tr>
<tr class="memdesc:ga553c3438e75628c6d7e2280989e539c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total size of the texture image data in bytes.  <a href="group__reader.html#ga553c3438e75628c6d7e2280989e539c4">More...</a><br /></td></tr>
<tr class="separator:ga553c3438e75628c6d7e2280989e539c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19d8786eea0e62ab55d945bff838d32c"><td class="memItemLeft" align="right" valign="top">ktx_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga19d8786eea0e62ab55d945bff838d32c">ktxTexture_GetElementSize</a> (<a class="el" href="structktxTexture.html">ktxTexture</a> *This)</td></tr>
<tr class="memdesc:ga19d8786eea0e62ab55d945bff838d32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size in bytes of an elements of a texture's images.  <a href="group__reader.html#ga19d8786eea0e62ab55d945bff838d32c">More...</a><br /></td></tr>
<tr class="separator:ga19d8786eea0e62ab55d945bff838d32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7c4b8bbe26379f2076f93050c0673c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gae7c4b8bbe26379f2076f93050c0673c1">ktxTexture_IterateLevelFaces</a> (<a class="el" href="structktxTexture.html">ktxTexture</a> *This, <a class="el" href="structktxTexture.html#aca6d87118e724ac77f17e0576e191513">PFNKTXITERCB</a> iterCb, void *userdata)</td></tr>
<tr class="memdesc:gae7c4b8bbe26379f2076f93050c0673c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the levels or faces in a <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a> object.  <a href="group__reader.html#gae7c4b8bbe26379f2076f93050c0673c1">More...</a><br /></td></tr>
<tr class="separator:gae7c4b8bbe26379f2076f93050c0673c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf9e393ff766982ccb79ad915975971f"><td class="memItemLeft" align="right" valign="top">ktx_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gacf9e393ff766982ccb79ad915975971f">ktxTexture_GetRowPitch</a> (<a class="el" href="structktxTexture.html">ktxTexture</a> *This, ktx_uint32_t level)</td></tr>
<tr class="memdesc:gacf9e393ff766982ccb79ad915975971f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pitch betweeb rows of a texture image level in bytes.  <a href="group__reader.html#gacf9e393ff766982ccb79ad915975971f">More...</a><br /></td></tr>
<tr class="separator:gacf9e393ff766982ccb79ad915975971f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4557b9714b41e7c575d295b65e19ed12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga4557b9714b41e7c575d295b65e19ed12">ktxTexture1_CreateFromStdioStream</a> (FILE *stdioStream, ktxTextureCreateFlags createFlags, <a class="el" href="structktxTexture1.html">ktxTexture1</a> **newTex)</td></tr>
<tr class="memdesc:ga4557b9714b41e7c575d295b65e19ed12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> from a stdio stream reading from a KTX source.  <a href="group__reader.html#ga4557b9714b41e7c575d295b65e19ed12">More...</a><br /></td></tr>
<tr class="separator:ga4557b9714b41e7c575d295b65e19ed12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0319d9a33d3ea78da2ef786205f2a956"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga0319d9a33d3ea78da2ef786205f2a956">ktxTexture1_CreateFromNamedFile</a> (const char *const filename, ktxTextureCreateFlags createFlags, <a class="el" href="structktxTexture1.html">ktxTexture1</a> **newTex)</td></tr>
<tr class="memdesc:ga0319d9a33d3ea78da2ef786205f2a956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> from a named KTX file.  <a href="group__reader.html#ga0319d9a33d3ea78da2ef786205f2a956">More...</a><br /></td></tr>
<tr class="separator:ga0319d9a33d3ea78da2ef786205f2a956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f289eb80601208b79561804d2ec0121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga1f289eb80601208b79561804d2ec0121">ktxTexture1_CreateFromMemory</a> (const ktx_uint8_t *bytes, ktx_size_t size, ktxTextureCreateFlags createFlags, <a class="el" href="structktxTexture1.html">ktxTexture1</a> **newTex)</td></tr>
<tr class="memdesc:ga1f289eb80601208b79561804d2ec0121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> from KTX-formatted data in memory.  <a href="group__reader.html#ga1f289eb80601208b79561804d2ec0121">More...</a><br /></td></tr>
<tr class="separator:ga1f289eb80601208b79561804d2ec0121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e9c9d8a1c02732c87db733d3449b337"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga2e9c9d8a1c02732c87db733d3449b337">ktxTexture1_CreateFromStream</a> (<a class="el" href="structktxStream.html">ktxStream</a> *pStream, ktxTextureCreateFlags createFlags, <a class="el" href="structktxTexture1.html">ktxTexture1</a> **newTex)</td></tr>
<tr class="memdesc:ga2e9c9d8a1c02732c87db733d3449b337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> from KTX-formatted data from a <code><a class="el" href="structktxStream.html" title="Interface of ktxStream.">ktxStream</a></code>.  <a href="group__reader.html#ga2e9c9d8a1c02732c87db733d3449b337">More...</a><br /></td></tr>
<tr class="separator:ga2e9c9d8a1c02732c87db733d3449b337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa616363178ec37996459219a6925f87d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaa616363178ec37996459219a6925f87d">ktxTexture1_Destroy</a> (<a class="el" href="structktxTexture1.html">ktxTexture1</a> *This)</td></tr>
<tr class="memdesc:gaa616363178ec37996459219a6925f87d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> object.  <a href="group__reader.html#gaa616363178ec37996459219a6925f87d">More...</a><br /></td></tr>
<tr class="separator:gaa616363178ec37996459219a6925f87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c471eb79f1ac62d63cae86ca6c519bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga2c471eb79f1ac62d63cae86ca6c519bf">ktxTexture1_GetImageOffset</a> (<a class="el" href="structktxTexture1.html">ktxTexture1</a> *This, ktx_uint32_t level, ktx_uint32_t layer, ktx_uint32_t faceSlice, ktx_size_t *pOffset)</td></tr>
<tr class="memdesc:ga2c471eb79f1ac62d63cae86ca6c519bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the offset of an image within a <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a>'s image data.  <a href="group__reader.html#ga2c471eb79f1ac62d63cae86ca6c519bf">More...</a><br /></td></tr>
<tr class="separator:ga2c471eb79f1ac62d63cae86ca6c519bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65cd751a3d1a6eed97cb19b7a88d736c"><td class="memItemLeft" align="right" valign="top">ktx_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga65cd751a3d1a6eed97cb19b7a88d736c">ktxTexture1_GetDataSizeUncompressed</a> (<a class="el" href="structktxTexture1.html">ktxTexture1</a> *This)</td></tr>
<tr class="memdesc:ga65cd751a3d1a6eed97cb19b7a88d736c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total size in bytes of the uncompressed data of a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a>.  <a href="group__reader.html#ga65cd751a3d1a6eed97cb19b7a88d736c">More...</a><br /></td></tr>
<tr class="separator:ga65cd751a3d1a6eed97cb19b7a88d736c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1dc0703bc613180a92a8e1c5901dd50"><td class="memItemLeft" align="right" valign="top">ktx_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gac1dc0703bc613180a92a8e1c5901dd50">ktxTexture1_GetImageSize</a> (<a class="el" href="structktxTexture1.html">ktxTexture1</a> *This, ktx_uint32_t level)</td></tr>
<tr class="memdesc:gac1dc0703bc613180a92a8e1c5901dd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate &amp; return the size in bytes of an image at the specified mip level.  <a href="group__reader.html#gac1dc0703bc613180a92a8e1c5901dd50">More...</a><br /></td></tr>
<tr class="separator:gac1dc0703bc613180a92a8e1c5901dd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga400a2581bf935beb6c0192a6e9844914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga400a2581bf935beb6c0192a6e9844914">ktxTexture1_IterateLevels</a> (<a class="el" href="structktxTexture1.html">ktxTexture1</a> *This, PFNKTXITERCB iterCb, void *userdata)</td></tr>
<tr class="memdesc:ga400a2581bf935beb6c0192a6e9844914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the mip levels in a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> object.  <a href="group__reader.html#ga400a2581bf935beb6c0192a6e9844914">More...</a><br /></td></tr>
<tr class="separator:ga400a2581bf935beb6c0192a6e9844914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab56e28f79781acf2933e36c21823c0df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gab56e28f79781acf2933e36c21823c0df">ktxTexture1_IterateLoadLevelFaces</a> (<a class="el" href="structktxTexture1.html">ktxTexture1</a> *This, PFNKTXITERCB iterCb, void *userdata)</td></tr>
<tr class="memdesc:gab56e28f79781acf2933e36c21823c0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the images in a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> object while loading the image data.  <a href="group__reader.html#gab56e28f79781acf2933e36c21823c0df">More...</a><br /></td></tr>
<tr class="separator:gab56e28f79781acf2933e36c21823c0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7334feb062f32b62159cebd6e4b28d16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga7334feb062f32b62159cebd6e4b28d16">ktxTexture1_LoadImageData</a> (<a class="el" href="structktxTexture1.html">ktxTexture1</a> *This, ktx_uint8_t *pBuffer, ktx_size_t bufSize)</td></tr>
<tr class="memdesc:ga7334feb062f32b62159cebd6e4b28d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all the image data from the <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a>'s source.  <a href="group__reader.html#ga7334feb062f32b62159cebd6e4b28d16">More...</a><br /></td></tr>
<tr class="separator:ga7334feb062f32b62159cebd6e4b28d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9de7e23ffe3ae3aeed4cc95c61699e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gae9de7e23ffe3ae3aeed4cc95c61699e4">ktxTexture2_CreateFromStdioStream</a> (FILE *stdioStream, ktxTextureCreateFlags createFlags, <a class="el" href="structktxTexture2.html">ktxTexture2</a> **newTex)</td></tr>
<tr class="memdesc:gae9de7e23ffe3ae3aeed4cc95c61699e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> from a stdio stream reading from a KTX source.  <a href="group__reader.html#gae9de7e23ffe3ae3aeed4cc95c61699e4">More...</a><br /></td></tr>
<tr class="separator:gae9de7e23ffe3ae3aeed4cc95c61699e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8680560274b31da6f3f07ee911055431"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga8680560274b31da6f3f07ee911055431">ktxTexture2_CreateFromNamedFile</a> (const char *const filename, ktxTextureCreateFlags createFlags, <a class="el" href="structktxTexture2.html">ktxTexture2</a> **newTex)</td></tr>
<tr class="memdesc:ga8680560274b31da6f3f07ee911055431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> from a named KTX file.  <a href="group__reader.html#ga8680560274b31da6f3f07ee911055431">More...</a><br /></td></tr>
<tr class="separator:ga8680560274b31da6f3f07ee911055431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6805a144f0bfd17b51d46fb28b0786a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga6805a144f0bfd17b51d46fb28b0786a5">ktxTexture2_CreateFromMemory</a> (const ktx_uint8_t *bytes, ktx_size_t size, ktxTextureCreateFlags createFlags, <a class="el" href="structktxTexture2.html">ktxTexture2</a> **newTex)</td></tr>
<tr class="memdesc:ga6805a144f0bfd17b51d46fb28b0786a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> from KTX-formatted data in memory.  <a href="group__reader.html#ga6805a144f0bfd17b51d46fb28b0786a5">More...</a><br /></td></tr>
<tr class="separator:ga6805a144f0bfd17b51d46fb28b0786a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e865473d23f82fc22a16bb3eadf60ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga1e865473d23f82fc22a16bb3eadf60ed">ktxTexture2_CreateFromStream</a> (<a class="el" href="structktxStream.html">ktxStream</a> *stream, ktxTextureCreateFlags createFlags, <a class="el" href="structktxTexture2.html">ktxTexture2</a> **newTex)</td></tr>
<tr class="memdesc:ga1e865473d23f82fc22a16bb3eadf60ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> from KTX-formatted data from a stream.  <a href="group__reader.html#ga1e865473d23f82fc22a16bb3eadf60ed">More...</a><br /></td></tr>
<tr class="separator:ga1e865473d23f82fc22a16bb3eadf60ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01ec49abe73b77f2f8db99b5d9cf46d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga01ec49abe73b77f2f8db99b5d9cf46d9">ktxTexture2_Destroy</a> (<a class="el" href="structktxTexture2.html">ktxTexture2</a> *This)</td></tr>
<tr class="memdesc:ga01ec49abe73b77f2f8db99b5d9cf46d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> object.  <a href="group__reader.html#ga01ec49abe73b77f2f8db99b5d9cf46d9">More...</a><br /></td></tr>
<tr class="separator:ga01ec49abe73b77f2f8db99b5d9cf46d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3aab08fa013c602fc055964e78c7566"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gad3aab08fa013c602fc055964e78c7566">ktxTexture2_GetComponentInfo</a> (<a class="el" href="structktxTexture2.html">ktxTexture2</a> *This, uint32_t *pNumComponents, uint32_t *pComponentByteLength)</td></tr>
<tr class="memdesc:gad3aab08fa013c602fc055964e78c7566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return information about the components of an image in a texture.  <a href="group__reader.html#gad3aab08fa013c602fc055964e78c7566">More...</a><br /></td></tr>
<tr class="separator:gad3aab08fa013c602fc055964e78c7566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc7762adb6ff311ca65cfe5ed89db21e"><td class="memItemLeft" align="right" valign="top">ktx_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gacc7762adb6ff311ca65cfe5ed89db21e">ktxTexture2_GetNumComponents</a> (<a class="el" href="structktxTexture2.html">ktxTexture2</a> *This)</td></tr>
<tr class="memdesc:gacc7762adb6ff311ca65cfe5ed89db21e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of components in an image of the texture.  <a href="group__reader.html#gacc7762adb6ff311ca65cfe5ed89db21e">More...</a><br /></td></tr>
<tr class="separator:gacc7762adb6ff311ca65cfe5ed89db21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab29978f318436c009ae45b7d3c515f8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gab29978f318436c009ae45b7d3c515f8e">ktxTexture2_GetImageOffset</a> (<a class="el" href="structktxTexture2.html">ktxTexture2</a> *This, ktx_uint32_t level, ktx_uint32_t layer, ktx_uint32_t faceSlice, ktx_size_t *pOffset)</td></tr>
<tr class="memdesc:gab29978f318436c009ae45b7d3c515f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the offset of an image within a <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a>'s image data.  <a href="group__reader.html#gab29978f318436c009ae45b7d3c515f8e">More...</a><br /></td></tr>
<tr class="separator:gab29978f318436c009ae45b7d3c515f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddf6746c18d970a238e89bb9b8e13e77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="khr__df_8h.html#a0bbb9bfb3e2a4c8e55a1242fa003f13e">khr_df_transfer_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaddf6746c18d970a238e89bb9b8e13e77">ktxTexture2_GetOETF_e</a> (<a class="el" href="structktxTexture2.html">ktxTexture2</a> *This)</td></tr>
<tr class="memdesc:gaddf6746c18d970a238e89bb9b8e13e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the opto-electrical transfer function of the images.  <a href="group__reader.html#gaddf6746c18d970a238e89bb9b8e13e77">More...</a><br /></td></tr>
<tr class="separator:gaddf6746c18d970a238e89bb9b8e13e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1b0eccd69f541450ed88da2ad260dcc"><td class="memItemLeft" align="right" valign="top">ktx_uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gac1b0eccd69f541450ed88da2ad260dcc">ktxTexture2_GetOETF</a> (<a class="el" href="structktxTexture2.html">ktxTexture2</a> *This)</td></tr>
<tr class="memdesc:gac1b0eccd69f541450ed88da2ad260dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the opto-electrical transfer function of the images.  <a href="group__reader.html#gac1b0eccd69f541450ed88da2ad260dcc">More...</a><br /></td></tr>
<tr class="separator:gac1b0eccd69f541450ed88da2ad260dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7200d548b480a3abb69c206f530c0669"><td class="memItemLeft" align="right" valign="top"><a class="el" href="khr__df_8h.html#ae926ceca94becbf6a9bc505696317e21">khr_df_model_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga7200d548b480a3abb69c206f530c0669">ktxTexture2_GetColorModel_e</a> (<a class="el" href="structktxTexture2.html">ktxTexture2</a> *This)</td></tr>
<tr class="memdesc:ga7200d548b480a3abb69c206f530c0669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the DFD color model of the images.  <a href="group__reader.html#ga7200d548b480a3abb69c206f530c0669">More...</a><br /></td></tr>
<tr class="separator:ga7200d548b480a3abb69c206f530c0669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab773b3ad45bacb6f487b62c4b0a07fcf"><td class="memItemLeft" align="right" valign="top">ktx_bool_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gab773b3ad45bacb6f487b62c4b0a07fcf">ktxTexture2_GetPremultipliedAlpha</a> (<a class="el" href="structktxTexture2.html">ktxTexture2</a> *This)</td></tr>
<tr class="memdesc:gab773b3ad45bacb6f487b62c4b0a07fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve whether the RGB components have been premultiplied by the alpha component.  <a href="group__reader.html#gab773b3ad45bacb6f487b62c4b0a07fcf">More...</a><br /></td></tr>
<tr class="separator:gab773b3ad45bacb6f487b62c4b0a07fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade1ffc5d31c2f9b5f1e861b59e7619ce"><td class="memItemLeft" align="right" valign="top">ktx_bool_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gade1ffc5d31c2f9b5f1e861b59e7619ce">ktxTexture2_NeedsTranscoding</a> (<a class="el" href="structktxTexture2.html">ktxTexture2</a> *This)</td></tr>
<tr class="memdesc:gade1ffc5d31c2f9b5f1e861b59e7619ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if the images are in a transcodable format.  <a href="group__reader.html#gade1ffc5d31c2f9b5f1e861b59e7619ce">More...</a><br /></td></tr>
<tr class="separator:gade1ffc5d31c2f9b5f1e861b59e7619ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefcaf84425830ba095eb670a275dad34"><td class="memItemLeft" align="right" valign="top">ktx_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaefcaf84425830ba095eb670a275dad34">ktxTexture2_GetDataSizeUncompressed</a> (<a class="el" href="structktxTexture2.html">ktxTexture2</a> *This)</td></tr>
<tr class="memdesc:gaefcaf84425830ba095eb670a275dad34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total size in bytes of the uncompressed data of a <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a>.  <a href="group__reader.html#gaefcaf84425830ba095eb670a275dad34">More...</a><br /></td></tr>
<tr class="separator:gaefcaf84425830ba095eb670a275dad34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4b800f418f57b10737ac6533f1769d2"><td class="memItemLeft" align="right" valign="top">ktx_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaa4b800f418f57b10737ac6533f1769d2">ktxTexture2_GetImageSize</a> (<a class="el" href="structktxTexture2.html">ktxTexture2</a> *This, ktx_uint32_t level)</td></tr>
<tr class="memdesc:gaa4b800f418f57b10737ac6533f1769d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate &amp; return the size in bytes of an image at the specified mip level.  <a href="group__reader.html#gaa4b800f418f57b10737ac6533f1769d2">More...</a><br /></td></tr>
<tr class="separator:gaa4b800f418f57b10737ac6533f1769d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b47270a151b67615aed9eeca5f25bf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga1b47270a151b67615aed9eeca5f25bf7">ktxTexture2_IterateLevels</a> (<a class="el" href="structktxTexture2.html">ktxTexture2</a> *This, PFNKTXITERCB iterCb, void *userdata)</td></tr>
<tr class="memdesc:ga1b47270a151b67615aed9eeca5f25bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the mip levels in a <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> object.  <a href="group__reader.html#ga1b47270a151b67615aed9eeca5f25bf7">More...</a><br /></td></tr>
<tr class="separator:ga1b47270a151b67615aed9eeca5f25bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf57628ec7f9a554b46ba84ab9c214bab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaf57628ec7f9a554b46ba84ab9c214bab">ktxTexture2_IterateLoadLevelFaces</a> (<a class="el" href="structktxTexture2.html">ktxTexture2</a> *This, PFNKTXITERCB iterCb, void *userdata)</td></tr>
<tr class="memdesc:gaf57628ec7f9a554b46ba84ab9c214bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the images in a <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> object while loading the image data.  <a href="group__reader.html#gaf57628ec7f9a554b46ba84ab9c214bab">More...</a><br /></td></tr>
<tr class="separator:gaf57628ec7f9a554b46ba84ab9c214bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09ecbaccf2a058f9e756ebb317230162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga09ecbaccf2a058f9e756ebb317230162">ktxTexture2_LoadImageData</a> (<a class="el" href="structktxTexture2.html">ktxTexture2</a> *This, ktx_uint8_t *pBuffer, ktx_size_t bufSize)</td></tr>
<tr class="memdesc:ga09ecbaccf2a058f9e756ebb317230162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load all the image data from the <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a>'s source.  <a href="group__reader.html#ga09ecbaccf2a058f9e756ebb317230162">More...</a><br /></td></tr>
<tr class="separator:ga09ecbaccf2a058f9e756ebb317230162"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Read KTX-formatted data. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1f289eb80601208b79561804d2ec0121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f289eb80601208b79561804d2ec0121">&#9670;&nbsp;</a></span>ktxTexture1_CreateFromMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture1_CreateFromMemory </td>
          <td>(</td>
          <td class="paramtype">const ktx_uint8_t *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktx_size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktxTextureCreateFlags&#160;</td>
          <td class="paramname"><em>createFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structktxTexture1.html">ktxTexture1</a> **&#160;</td>
          <td class="paramname"><em>newTex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> from KTX-formatted data in memory. </p>
<p>The address of a newly created texture reflecting the contents of the serialized KTX data is written to the location pointed at by <code>newTex</code>.</p>
<p>The create flag KTX_TEXTURE_CREATE_LOAD_IMAGE_DATA_BIT should not be set, if the <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> is ultimately to be uploaded to OpenGL or Vulkan. This will minimize memory usage by allowing, for example, loading the images directly from the source into a Vulkan staging buffer.</p>
<p>The create flag KTX_TEXTURE_CREATE_RAW_KVDATA_BIT should not be used. It is provided solely to enable implementation of the <em>libktx</em> v1 API on top of <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes</td><td>pointer to the memory containing the serialized KTX data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>length of the KTX data in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">createFlags</td><td>bitmask requesting specific actions during creation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newTex</td><td>pointer to a location in which store the address of the newly created texture.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>KTX_SUCCESS on success, other KTX_* enum values on error.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KTX_INVALID_VALUE</td><td>Either <code>bytes</code> is NULL or <code>size</code> is 0.</td></tr>
  </table>
  </dd>
</dl>
<p>For other exceptions, see <a class="el" href="group__reader.html#ga4557b9714b41e7c575d295b65e19ed12" title="Create a ktxTexture1 from a stdio stream reading from a KTX source.">ktxTexture1_CreateFromStdioStream()</a>. </p>

</div>
</div>
<a id="ga0319d9a33d3ea78da2ef786205f2a956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0319d9a33d3ea78da2ef786205f2a956">&#9670;&nbsp;</a></span>ktxTexture1_CreateFromNamedFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture1_CreateFromNamedFile </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktxTextureCreateFlags&#160;</td>
          <td class="paramname"><em>createFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structktxTexture1.html">ktxTexture1</a> **&#160;</td>
          <td class="paramname"><em>newTex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> from a named KTX file. </p>
<p>The address of a newly created texture reflecting the contents of the file is written to the location pointed at by <code>newTex</code>.</p>
<p>The file name must be encoded in utf-8. On Windows convert unicode names to utf-8 with <code>WideCharToMultiByte(CP_UTF8, ...)</code> before calling.</p>
<p>The create flag KTX_TEXTURE_CREATE_LOAD_IMAGE_DATA_BIT should not be set, if the <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> is ultimately to be uploaded to OpenGL or Vulkan. This will minimize memory usage by allowing, for example, loading the images directly from the source into a Vulkan staging buffer.</p>
<p>The create flag KTX_TEXTURE_CREATE_RAW_KVDATA_BIT should not be used. It is provided solely to enable implementation of the <em>libktx</em> v1 API on top of <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>pointer to a char array containing the file name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">createFlags</td><td>bitmask requesting specific actions during creation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newTex</td><td>pointer to a location in which store the address of the newly created texture.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>KTX_SUCCESS on success, other KTX_* enum values on error.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KTX_FILE_OPEN_FAILED</td><td>The file could not be opened. </td></tr>
    <tr><td class="paramname">KTX_INVALID_VALUE</td><td><code>filename</code> is <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>For other exceptions, see <a class="el" href="group__reader.html#ga4557b9714b41e7c575d295b65e19ed12" title="Create a ktxTexture1 from a stdio stream reading from a KTX source.">ktxTexture1_CreateFromStdioStream()</a>. </p>

</div>
</div>
<a id="ga4557b9714b41e7c575d295b65e19ed12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4557b9714b41e7c575d295b65e19ed12">&#9670;&nbsp;</a></span>ktxTexture1_CreateFromStdioStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture1_CreateFromStdioStream </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stdioStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktxTextureCreateFlags&#160;</td>
          <td class="paramname"><em>createFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structktxTexture1.html">ktxTexture1</a> **&#160;</td>
          <td class="paramname"><em>newTex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> from a stdio stream reading from a KTX source. </p>
<p>The address of a newly created texture reflecting the contents of the stdio stream is written to the location pointed at by <code>newTex</code>.</p>
<p>The create flag KTX_TEXTURE_CREATE_LOAD_IMAGE_DATA_BIT should not be set, if the <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> is ultimately to be uploaded to OpenGL or Vulkan. This will minimize memory usage by allowing, for example, loading the images directly from the source into a Vulkan staging buffer.</p>
<p>The create flag KTX_TEXTURE_CREATE_RAW_KVDATA_BIT should not be used. It is provided solely to enable implementation of the <em>libktx</em> v1 API on top of <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stdioStream</td><td>stdio FILE pointer created from the desired file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">createFlags</td><td>bitmask requesting specific actions during creation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newTex</td><td>pointer to a location in which store the address of the newly created texture.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>KTX_SUCCESS on success, other KTX_* enum values on error.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KTX_INVALID_VALUE</td><td><code>newTex</code> is <code>NULL</code>. </td></tr>
    <tr><td class="paramname">KTX_FILE_DATA_ERROR</td><td>Source data is inconsistent with the KTX specification. </td></tr>
    <tr><td class="paramname">KTX_FILE_READ_ERROR</td><td>An error occurred while reading the source. </td></tr>
    <tr><td class="paramname">KTX_FILE_UNEXPECTED_EOF</td><td>Not enough data in the source. </td></tr>
    <tr><td class="paramname">KTX_OUT_OF_MEMORY</td><td>Not enough memory to create the texture object, load the images or load the key-value data. </td></tr>
    <tr><td class="paramname">KTX_UNKNOWN_FILE_FORMAT</td><td>The source is not in KTX format. </td></tr>
    <tr><td class="paramname">KTX_UNSUPPORTED_TEXTURE_TYPE</td><td>The source describes a texture type not supported by OpenGL or Vulkan, e.g, a 3D array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2e9c9d8a1c02732c87db733d3449b337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e9c9d8a1c02732c87db733d3449b337">&#9670;&nbsp;</a></span>ktxTexture1_CreateFromStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture1_CreateFromStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxStream.html">ktxStream</a> *&#160;</td>
          <td class="paramname"><em>pStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktxTextureCreateFlags&#160;</td>
          <td class="paramname"><em>createFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structktxTexture1.html">ktxTexture1</a> **&#160;</td>
          <td class="paramname"><em>newTex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> from KTX-formatted data from a <code><a class="el" href="structktxStream.html" title="Interface of ktxStream.">ktxStream</a></code>. </p>
<p>The address of a newly created texture reflecting the contents of the serialized KTX data is written to the location pointed at by <code>newTex</code>.</p>
<p>The create flag KTX_TEXTURE_CREATE_LOAD_IMAGE_DATA_BIT should not be set, if the <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> is ultimately to be uploaded to OpenGL or Vulkan. This will minimize memory usage by allowing, for example, loading the images directly from the source into a Vulkan staging buffer.</p>
<p>The create flag KTX_TEXTURE_CREATE_RAW_KVDATA_BIT should not be used. It is provided solely to enable implementation of the <em>libktx</em> v1 API on top of <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pStream</td><td>pointer to the stream to read KTX data from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">createFlags</td><td>bitmask requesting specific actions during creation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newTex</td><td>pointer to a location in which store the address of the newly created texture.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>KTX_SUCCESS on success, other KTX_* enum values on error.</dd></dl>
<p>For exceptions, see <a class="el" href="group__reader.html#ga4557b9714b41e7c575d295b65e19ed12" title="Create a ktxTexture1 from a stdio stream reading from a KTX source.">ktxTexture1_CreateFromStdioStream()</a>. </p>

</div>
</div>
<a id="gaa616363178ec37996459219a6925f87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa616363178ec37996459219a6925f87d">&#9670;&nbsp;</a></span>ktxTexture1_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktxTexture1_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture1.html">ktxTexture1</a> *&#160;</td>
          <td class="paramname"><em>This</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> object. </p>
<p>This frees the memory associated with the texture contents and the memory of the <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> object. This does <em>not</em> delete any OpenGL or Vulkan texture objects created by ktxTexture1_GLUpload or ktxTexture1_VkUpload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> object to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga65cd751a3d1a6eed97cb19b7a88d736c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65cd751a3d1a6eed97cb19b7a88d736c">&#9670;&nbsp;</a></span>ktxTexture1_GetDataSizeUncompressed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ktx_size_t ktxTexture1_GetDataSizeUncompressed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture1.html">ktxTexture1</a> *&#160;</td>
          <td class="paramname"><em>This</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the total size in bytes of the uncompressed data of a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a>. </p>
<p>This always returns the value of <code>This-&gt;dataSize</code>. The function is provided for symmetry with <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> object of interest. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the data in the texture. </dd></dl>

</div>
</div>
<a id="ga2c471eb79f1ac62d63cae86ca6c519bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c471eb79f1ac62d63cae86ca6c519bf">&#9670;&nbsp;</a></span>ktxTexture1_GetImageOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture1_GetImageOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture1.html">ktxTexture1</a> *&#160;</td>
          <td class="paramname"><em>This</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktx_uint32_t&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktx_uint32_t&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktx_uint32_t&#160;</td>
          <td class="paramname"><em>faceSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktx_size_t *&#160;</td>
          <td class="paramname"><em>pOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the offset of an image within a <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a>'s image data. </p>
<p>As there is no such thing as a 3D cubemap we make the 3rd location parameter do double duty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a> object of interest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>mip level of the image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>array layer of the image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceSlice</td><td>cube map face or depth slice of the image. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOffset</td><td>pointer to location to store the offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>KTX_SUCCESS on success, other KTX_* enum values on error.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KTX_INVALID_OPERATION</td><td><code>level</code>, <code>layer</code> or <code>faceSlice</code> exceed the dimensions of the texture. </td></tr>
    <tr><td class="paramname">KTX_INVALID_VALID</td><td><code>This</code> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac1dc0703bc613180a92a8e1c5901dd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1dc0703bc613180a92a8e1c5901dd50">&#9670;&nbsp;</a></span>ktxTexture1_GetImageSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ktx_size_t ktxTexture1_GetImageSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture1.html">ktxTexture1</a> *&#160;</td>
          <td class="paramname"><em>This</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktx_uint32_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate &amp; return the size in bytes of an image at the specified mip level. </p>
<p>For arrays, this is the size of layer, for cubemaps, the size of a face and for 3D textures, the size of a depth slice.</p>
<p>The size reflects the padding of each row to KTX_GL_UNPACK_ALIGNMENT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> object of interest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>level of interest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga400a2581bf935beb6c0192a6e9844914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga400a2581bf935beb6c0192a6e9844914">&#9670;&nbsp;</a></span>ktxTexture1_IterateLevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture1_IterateLevels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture1.html">ktxTexture1</a> *&#160;</td>
          <td class="paramname"><em>This</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PFNKTXITERCB&#160;</td>
          <td class="paramname"><em>iterCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over the mip levels in a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> object. </p>
<p>This is almost identical to <a class="el" href="group__reader.html#gae7c4b8bbe26379f2076f93050c0673c1">ktxTexture_IterateLevelFaces</a>. The difference is that the blocks of image data for non-array cube maps include all faces of a mip level.</p>
<p>This function works even if <code>This-&gt;pData</code> == 0 so it can be used to obtain offsets and sizes for each level by callers who have loaded the data externally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>handle of the 1 opened on the data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iterCb</td><td>the address of a callback function which is called with the data for each image block. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">userdata</td><td>the address of application-specific data which is passed to the callback along with the image data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>KTX_SUCCESS on success, other KTX_* enum values on error. The following are returned directly by this function. <code>iterCb</code> may return these for other causes or may return additional errors.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KTX_FILE_DATA_ERROR</td><td>Mip level sizes are increasing not decreasing </td></tr>
    <tr><td class="paramname">KTX_INVALID_VALUE</td><td><code>This</code> is <code>NULL</code> or <code>iterCb</code> is <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab56e28f79781acf2933e36c21823c0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab56e28f79781acf2933e36c21823c0df">&#9670;&nbsp;</a></span>ktxTexture1_IterateLoadLevelFaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture1_IterateLoadLevelFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture1.html">ktxTexture1</a> *&#160;</td>
          <td class="paramname"><em>This</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PFNKTXITERCB&#160;</td>
          <td class="paramname"><em>iterCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over the images in a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> object while loading the image data. </p>
<p>This operates similarly to <a class="el" href="group__reader.html#gae7c4b8bbe26379f2076f93050c0673c1">ktxTexture_IterateLevelFaces</a> except that it loads the images from the <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a>'s source to a temporary buffer while iterating. The callback function must copy the image data if it wishes to preserve it as the temporary buffer is reused for each level and is freed when this function exits.</p>
<p>This function is helpful for reducing memory usage when uploading the data to a graphics API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> object of interest. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iterCb</td><td>the address of a callback function which is called with the data for each image. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">userdata</td><td>the address of application-specific data which is passed to the callback along with the image data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>KTX_SUCCESS on success, other KTX_* enum values on error. The following are returned directly by this function. <code>iterCb</code> may return these for other causes or may return additional errors.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KTX_FILE_DATA_ERROR</td><td>mip level sizes are increasing not decreasing </td></tr>
    <tr><td class="paramname">KTX_INVALID_OPERATION</td><td>the <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> was not created from a stream, i.e there is no data to load, or this <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a>'s images have already been loaded. </td></tr>
    <tr><td class="paramname">KTX_INVALID_VALUE</td><td><code>This</code> is <code>NULL</code> or <code>iterCb</code> is <code>NULL</code>. </td></tr>
    <tr><td class="paramname">KTX_OUT_OF_MEMORY</td><td>not enough memory to allocate a block to hold the base level image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7334feb062f32b62159cebd6e4b28d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7334feb062f32b62159cebd6e4b28d16">&#9670;&nbsp;</a></span>ktxTexture1_LoadImageData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture1_LoadImageData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture1.html">ktxTexture1</a> *&#160;</td>
          <td class="paramname"><em>This</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktx_uint8_t *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktx_size_t&#160;</td>
          <td class="paramname"><em>bufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load all the image data from the <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a>'s source. </p>
<p>The data is loaded into the provided buffer or to an internally allocated buffer, if <code>pBuffer</code> is <code>NULL</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a> object of interest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>pointer to the buffer in which to load the image data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufSize</td><td>size of the buffer pointed at by <code>pBuffer</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>KTX_SUCCESS on success, other KTX_* enum values on error.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KTX_INVALID_VALUE</td><td><code>This</code> is NULL. </td></tr>
    <tr><td class="paramname">KTX_INVALID_VALUE</td><td><code>bufSize</code> is less than the the image data size. </td></tr>
    <tr><td class="paramname">KTX_INVALID_OPERATION</td><td>The data has already been loaded or the <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a> was not created from a KTX source. </td></tr>
    <tr><td class="paramname">KTX_OUT_OF_MEMORY</td><td>Insufficient memory for the image data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6805a144f0bfd17b51d46fb28b0786a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6805a144f0bfd17b51d46fb28b0786a5">&#9670;&nbsp;</a></span>ktxTexture2_CreateFromMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture2_CreateFromMemory </td>
          <td>(</td>
          <td class="paramtype">const ktx_uint8_t *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktx_size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktxTextureCreateFlags&#160;</td>
          <td class="paramname"><em>createFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structktxTexture2.html">ktxTexture2</a> **&#160;</td>
          <td class="paramname"><em>newTex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> from KTX-formatted data in memory. </p>
<p>The address of a newly created <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> reflecting the contents of the serialized KTX data is written to the location pointed at by <code>newTex</code>.</p>
<p>The create flag KTX_TEXTURE_CREATE_LOAD_IMAGE_DATA_BIT should not be set, if the <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a> is ultimately to be uploaded to OpenGL or Vulkan. This will minimize memory usage by allowing, for example, loading the images directly from the source into a Vulkan staging buffer.</p>
<p>The create flag KTX_TEXTURE_CREATE_RAW_KVDATA_BIT should not be used. It is provided solely to enable implementation of the <em>libktx</em> v1 API on top of <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes</td><td>pointer to the memory containing the serialized KTX data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>length of the KTX data in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">createFlags</td><td>bitmask requesting specific actions during creation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newTex</td><td>pointer to a location in which store the address of the newly created texture.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>KTX_SUCCESS on success, other KTX_* enum values on error.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KTX_INVALID_VALUE</td><td>Either <code>bytes</code> is NULL or <code>size</code> is 0.</td></tr>
  </table>
  </dd>
</dl>
<p>For other exceptions, see <a class="el" href="group__reader.html#ga180d93562cc6af30c61adf8f6a8fd827" title="Create a ktxTexture1 or ktxTexture2 from a stdio stream according to the stream data.">ktxTexture_CreateFromStdioStream()</a>. </p>

</div>
</div>
<a id="ga8680560274b31da6f3f07ee911055431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8680560274b31da6f3f07ee911055431">&#9670;&nbsp;</a></span>ktxTexture2_CreateFromNamedFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture2_CreateFromNamedFile </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktxTextureCreateFlags&#160;</td>
          <td class="paramname"><em>createFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structktxTexture2.html">ktxTexture2</a> **&#160;</td>
          <td class="paramname"><em>newTex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> from a named KTX file. </p>
<p>The address of a newly created <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> reflecting the contents of the file is written to the location pointed at by <code>newTex</code>.</p>
<p>The file name must be encoded in utf-8. On Windows convert unicode names to utf-8 with <code>WideCharToMultiByte(CP_UTF8, ...)</code> before calling.</p>
<p>The create flag KTX_TEXTURE_CREATE_LOAD_IMAGE_DATA_BIT should not be set, if the <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a> is ultimately to be uploaded to OpenGL or Vulkan. This will minimize memory usage by allowing, for example, loading the images directly from the source into a Vulkan staging buffer.</p>
<p>The create flag KTX_TEXTURE_CREATE_RAW_KVDATA_BIT should not be used. It is provided solely to enable implementation of the <em>libktx</em> v1 API on top of <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>pointer to a char array containing the file name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">createFlags</td><td>bitmask requesting specific actions during creation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newTex</td><td>pointer to a location in which store the address of the newly created texture.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>KTX_SUCCESS on success, other KTX_* enum values on error.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KTX_FILE_OPEN_FAILED</td><td>The file could not be opened. </td></tr>
    <tr><td class="paramname">KTX_INVALID_VALUE</td><td><code>filename</code> is <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>For other exceptions, see <a class="el" href="group__reader.html#ga180d93562cc6af30c61adf8f6a8fd827" title="Create a ktxTexture1 or ktxTexture2 from a stdio stream according to the stream data.">ktxTexture_CreateFromStdioStream()</a>. </p>

</div>
</div>
<a id="gae9de7e23ffe3ae3aeed4cc95c61699e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9de7e23ffe3ae3aeed4cc95c61699e4">&#9670;&nbsp;</a></span>ktxTexture2_CreateFromStdioStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture2_CreateFromStdioStream </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stdioStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktxTextureCreateFlags&#160;</td>
          <td class="paramname"><em>createFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structktxTexture2.html">ktxTexture2</a> **&#160;</td>
          <td class="paramname"><em>newTex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> from a stdio stream reading from a KTX source. </p>
<p>The address of a newly created <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> reflecting the contents of the stdio stream is written to the location pointed at by <code>newTex</code>.</p>
<p>The create flag KTX_TEXTURE_CREATE_LOAD_IMAGE_DATA_BIT should not be set, if the <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a> is ultimately to be uploaded to OpenGL or Vulkan. This will minimize memory usage by allowing, for example, loading the images directly from the source into a Vulkan staging buffer.</p>
<p>The create flag KTX_TEXTURE_CREATE_RAW_KVDATA_BIT should not be used. It is provided solely to enable implementation of the <em>libktx</em> v1 API on top of <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stdioStream</td><td>stdio FILE pointer created from the desired file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">createFlags</td><td>bitmask requesting specific actions during creation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newTex</td><td>pointer to a location in which store the address of the newly created texture.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>KTX_SUCCESS on success, other KTX_* enum values on error.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KTX_INVALID_VALUE</td><td><code>newTex</code> is <code>NULL</code>. </td></tr>
    <tr><td class="paramname">KTX_FILE_DATA_ERROR</td><td>Source data is inconsistent with the KTX specification. </td></tr>
    <tr><td class="paramname">KTX_FILE_READ_ERROR</td><td>An error occurred while reading the source. </td></tr>
    <tr><td class="paramname">KTX_FILE_UNEXPECTED_EOF</td><td>Not enough data in the source. </td></tr>
    <tr><td class="paramname">KTX_OUT_OF_MEMORY</td><td>Not enough memory to create the texture object, load the images or load the key-value data. </td></tr>
    <tr><td class="paramname">KTX_UNKNOWN_FILE_FORMAT</td><td>The source is not in KTX format. </td></tr>
    <tr><td class="paramname">KTX_UNSUPPORTED_TEXTURE_TYPE</td><td>The source describes a texture type not supported by OpenGL or Vulkan, e.g, a 3D array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1e865473d23f82fc22a16bb3eadf60ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e865473d23f82fc22a16bb3eadf60ed">&#9670;&nbsp;</a></span>ktxTexture2_CreateFromStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture2_CreateFromStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxStream.html">ktxStream</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktxTextureCreateFlags&#160;</td>
          <td class="paramname"><em>createFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structktxTexture2.html">ktxTexture2</a> **&#160;</td>
          <td class="paramname"><em>newTex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> from KTX-formatted data from a stream. </p>
<p>The address of a newly created <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> reflecting the contents of the serialized KTX data is written to the location pointed at by <code>newTex</code>.</p>
<p>The create flag KTX_TEXTURE_CREATE_LOAD_IMAGE_DATA_BIT should not be set, if the <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a> is ultimately to be uploaded to OpenGL or Vulkan. This will minimize memory usage by allowing, for example, loading the images directly from the source into a Vulkan staging buffer.</p>
<p>The create flag KTX_TEXTURE_CREATE_RAW_KVDATA_BIT should not be used. It is provided solely to enable implementation of the <em>libktx</em> v1 API on top of <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>pointer to the stream to read KTX data from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">createFlags</td><td>bitmask requesting specific actions during creation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newTex</td><td>pointer to a location in which store the address of the newly created texture.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>KTX_SUCCESS on success, other KTX_* enum values on error.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KTX_INVALID_VALUE</td><td>Either <code>bytes</code> is NULL or <code>size</code> is 0.</td></tr>
  </table>
  </dd>
</dl>
<p>For other exceptions, see <a class="el" href="group__reader.html#ga180d93562cc6af30c61adf8f6a8fd827" title="Create a ktxTexture1 or ktxTexture2 from a stdio stream according to the stream data.">ktxTexture_CreateFromStdioStream()</a>. </p>

</div>
</div>
<a id="ga01ec49abe73b77f2f8db99b5d9cf46d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01ec49abe73b77f2f8db99b5d9cf46d9">&#9670;&nbsp;</a></span>ktxTexture2_Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktxTexture2_Destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture2.html">ktxTexture2</a> *&#160;</td>
          <td class="paramname"><em>This</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> object. </p>
<p>This frees the memory associated with the texture contents and the memory of the <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> object. This does <em>not</em> delete any OpenGL or Vulkan texture objects created by ktxTexture2_GLUpload or ktxTexture2_VkUpload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> object to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7200d548b480a3abb69c206f530c0669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7200d548b480a3abb69c206f530c0669">&#9670;&nbsp;</a></span>ktxTexture2_GetColorModel_e()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="khr__df_8h.html#ae926ceca94becbf6a9bc505696317e21">khr_df_model_e</a> ktxTexture2_GetColorModel_e </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture2.html">ktxTexture2</a> *&#160;</td>
          <td class="paramname"><em>This</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the DFD color model of the images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> object of interest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>khr_df_transfer</code> enum value specifying the color model. </dd></dl>

</div>
</div>
<a id="gad3aab08fa013c602fc055964e78c7566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3aab08fa013c602fc055964e78c7566">&#9670;&nbsp;</a></span>ktxTexture2_GetComponentInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ktxTexture2_GetComponentInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture2.html">ktxTexture2</a> *&#160;</td>
          <td class="paramname"><em>This</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pNumComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pComponentByteLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return information about the components of an image in a texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a> object of interest. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pNumComponents</td><td>pointer to location in which to write the number of components in the textures images. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pComponentByteLength</td><td>pointer to the location in which to write byte length of a component. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaefcaf84425830ba095eb670a275dad34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefcaf84425830ba095eb670a275dad34">&#9670;&nbsp;</a></span>ktxTexture2_GetDataSizeUncompressed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ktx_size_t ktxTexture2_GetDataSizeUncompressed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture2.html">ktxTexture2</a> *&#160;</td>
          <td class="paramname"><em>This</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the total size in bytes of the uncompressed data of a <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a>. </p>
<p>If supercompressionScheme == <code>KTX_SS_NONE</code> or <code>KTX_SS_BASIS_LZ</code>, returns the value of <code>This-&gt;dataSize</code> else if supercompressionScheme == <code>KTX_SS_ZSTD</code> or <code>KTX_SS_ZLIB</code>, it returns the sum of the uncompressed sizes of each mip level plus space for the level padding. With no supercompression the data size and uncompressed data size are the same. For Basis supercompression the uncompressed size cannot be known until the data is transcoded so the compressed size is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> object of interest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab29978f318436c009ae45b7d3c515f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab29978f318436c009ae45b7d3c515f8e">&#9670;&nbsp;</a></span>ktxTexture2_GetImageOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture2_GetImageOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture2.html">ktxTexture2</a> *&#160;</td>
          <td class="paramname"><em>This</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktx_uint32_t&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktx_uint32_t&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktx_uint32_t&#160;</td>
          <td class="paramname"><em>faceSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktx_size_t *&#160;</td>
          <td class="paramname"><em>pOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the offset of an image within a <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a>'s image data. </p>
<p>As there is no such thing as a 3D cubemap we make the 3rd location parameter do double duty. Only works for non-supercompressed textures as there is no way to tell where an image is for a supercompressed one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a> object of interest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>mip level of the image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layer</td><td>array layer of the image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceSlice</td><td>cube map face or depth slice of the image. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pOffset</td><td>pointer to location to store the offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>KTX_SUCCESS on success, other KTX_* enum values on error.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KTX_INVALID_OPERATION</td><td><code>level</code>, <code>layer</code> or <code>faceSlice</code> exceed the dimensions of the texture. </td></tr>
    <tr><td class="paramname">KTX_INVALID_OPERATION</td><td>Texture is supercompressed. </td></tr>
    <tr><td class="paramname">KTX_INVALID_VALID</td><td><code>This</code> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa4b800f418f57b10737ac6533f1769d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4b800f418f57b10737ac6533f1769d2">&#9670;&nbsp;</a></span>ktxTexture2_GetImageSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ktx_size_t ktxTexture2_GetImageSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture2.html">ktxTexture2</a> *&#160;</td>
          <td class="paramname"><em>This</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktx_uint32_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate &amp; return the size in bytes of an image at the specified mip level. </p>
<p>For arrays, this is the size of a layer, for cubemaps, the size of a face and for 3D textures, the size of a depth slice.</p>
<p>The size reflects the padding of each row to KTX_GL_UNPACK_ALIGNMENT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> object of interest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>level of interest. * </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacc7762adb6ff311ca65cfe5ed89db21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc7762adb6ff311ca65cfe5ed89db21e">&#9670;&nbsp;</a></span>ktxTexture2_GetNumComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ktx_uint32_t ktxTexture2_GetNumComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture2.html">ktxTexture2</a> *&#160;</td>
          <td class="paramname"><em>This</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of components in an image of the texture. </p>
<p>Returns the number of components indicated by the DFD's sample information in accordance with the color model. For uncompressed formats it will be the actual number of components in the image. For block-compressed formats, it will be 1 or 2 according to the format's DFD color model. For Basis compressed textures, the function examines the ids of the channels indicated by the DFD and uses that information to determine and return the number of components in the image <em>before</em> encoding and deflation so it can be used to help choose a suitable transcode target format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a> object of interest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of components. </dd></dl>

</div>
</div>
<a id="gac1b0eccd69f541450ed88da2ad260dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1b0eccd69f541450ed88da2ad260dcc">&#9670;&nbsp;</a></span>ktxTexture2_GetOETF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ktx_uint32_t ktxTexture2_GetOETF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture2.html">ktxTexture2</a> *&#160;</td>
          <td class="paramname"><em>This</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the opto-electrical transfer function of the images. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>Retained for backward compatibility. Use <a class="el" href="group__reader.html#gaddf6746c18d970a238e89bb9b8e13e77" title="Retrieve the opto-electrical transfer function of the images.">ktxTexture2_GetOETF_e()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> object of interest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>khr_df_transfer</code> enum value specifying the OETF, returned as <code>ktx_uint32_t</code>. </dd></dl>

</div>
</div>
<a id="gaddf6746c18d970a238e89bb9b8e13e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddf6746c18d970a238e89bb9b8e13e77">&#9670;&nbsp;</a></span>ktxTexture2_GetOETF_e()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="khr__df_8h.html#a0bbb9bfb3e2a4c8e55a1242fa003f13e">khr_df_transfer_e</a> ktxTexture2_GetOETF_e </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture2.html">ktxTexture2</a> *&#160;</td>
          <td class="paramname"><em>This</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the opto-electrical transfer function of the images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> object of interest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>khr_df_transfer</code> enum value specifying the OETF. </dd></dl>

</div>
</div>
<a id="gab773b3ad45bacb6f487b62c4b0a07fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab773b3ad45bacb6f487b62c4b0a07fcf">&#9670;&nbsp;</a></span>ktxTexture2_GetPremultipliedAlpha()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ktx_bool_t ktxTexture2_GetPremultipliedAlpha </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture2.html">ktxTexture2</a> *&#160;</td>
          <td class="paramname"><em>This</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve whether the RGB components have been premultiplied by the alpha component. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> object of interest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>KTX_TRUE if the components are premultiplied, KTX_FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ga1b47270a151b67615aed9eeca5f25bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b47270a151b67615aed9eeca5f25bf7">&#9670;&nbsp;</a></span>ktxTexture2_IterateLevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture2_IterateLevels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture2.html">ktxTexture2</a> *&#160;</td>
          <td class="paramname"><em>This</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PFNKTXITERCB&#160;</td>
          <td class="paramname"><em>iterCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over the mip levels in a <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> object. </p>
<p>This is almost identical to <a class="el" href="group__reader.html#gae7c4b8bbe26379f2076f93050c0673c1" title="Iterate over the levels or faces in a ktxTexture object.">ktxTexture_IterateLevelFaces()</a>. The difference is that the blocks of image data for non-array cube maps include all faces of a mip level.</p>
<p>This function works even if <code>This-&gt;pData</code> == 0 so it can be used to obtain offsets and sizes for each level by callers who have loaded the data externally.</p>
<p>Intended for use only when supercompressionScheme == SUPERCOMPRESSION_NONE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>handle of the <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a> opened on the data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iterCb</td><td>the address of a callback function which is called with the data for each image block. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">userdata</td><td>the address of application-specific data which is passed to the callback along with the image data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>KTX_SUCCESS on success, other KTX_* enum values on error. The following are returned directly by this function. <code>iterCb</code> may return these for other causes or may return additional errors.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KTX_FILE_DATA_ERROR</td><td>Mip level sizes are increasing not decreasing </td></tr>
    <tr><td class="paramname">KTX_INVALID_OPERATION</td><td>supercompressionScheme != SUPERCOMPRESSION_NONE. </td></tr>
    <tr><td class="paramname">KTX_INVALID_VALUE</td><td><code>This</code> is <code>NULL</code> or <code>iterCb</code> is <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf57628ec7f9a554b46ba84ab9c214bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf57628ec7f9a554b46ba84ab9c214bab">&#9670;&nbsp;</a></span>ktxTexture2_IterateLoadLevelFaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture2_IterateLoadLevelFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture2.html">ktxTexture2</a> *&#160;</td>
          <td class="paramname"><em>This</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PFNKTXITERCB&#160;</td>
          <td class="paramname"><em>iterCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over the images in a <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> object while loading the image data. </p>
<p>This operates similarly to <a class="el" href="group__reader.html#gae7c4b8bbe26379f2076f93050c0673c1" title="Iterate over the levels or faces in a ktxTexture object.">ktxTexture_IterateLevelFaces()</a> except that it loads the images from the <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a>'s source to a temporary buffer while iterating. If supercompressionScheme == KTX_SS_ZSTD or KTX_SS_ZLIB, it will inflate the data before passing it to the callback. The callback function must copy the image data if it wishes to preserve it as the temporary buffer is reused for each level and is freed when this function exits.</p>
<p>This function is helpful for reducing memory usage when uploading the data to a graphics API.</p>
<p>Intended for use only when supercompressionScheme == KTX_SS_NONE, KTX_SS_ZSTD or KTX_SS_ZLIB. As there is no access to the <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a>'s data on conclusion of this function, destroying the texture on completion is recommended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> object of interest. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iterCb</td><td>the address of a callback function which is called with the data for each image. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">userdata</td><td>the address of application-specific data which is passed to the callback along with the image data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>KTX_SUCCESS on success, other KTX_* enum values on error. The following are returned directly by this function. <code>iterCb</code> may return these for other causes or may return additional errors.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KTX_FILE_DATA_ERROR</td><td>mip level sizes are increasing not decreasing </td></tr>
    <tr><td class="paramname">KTX_INVALID_OPERATION</td><td>the <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> was not created from a stream, i.e there is no data to load, or this <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a>'s images have already been loaded. </td></tr>
    <tr><td class="paramname">KTX_INVALID_OPERATION</td><td>supercompressionScheme != KTX_SS_NONE, supercompressionScheme != KTX_SS_ZSTD, and supercompressionScheme != KTX_SS_ZLIB. </td></tr>
    <tr><td class="paramname">KTX_INVALID_VALUE</td><td><code>This</code> is <code>NULL</code> or <code>iterCb</code> is <code>NULL</code>. </td></tr>
    <tr><td class="paramname">KTX_OUT_OF_MEMORY</td><td>not enough memory to allocate a block to hold the base level image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga09ecbaccf2a058f9e756ebb317230162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09ecbaccf2a058f9e756ebb317230162">&#9670;&nbsp;</a></span>ktxTexture2_LoadImageData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture2_LoadImageData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture2.html">ktxTexture2</a> *&#160;</td>
          <td class="paramname"><em>This</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktx_uint8_t *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktx_size_t&#160;</td>
          <td class="paramname"><em>bufSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load all the image data from the <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a>'s source. </p>
<p>The data will be inflated if supercompressionScheme == <code>KTX_SS_ZSTD</code> or <code>KTX_SS_ZLIB</code>. The data is loaded into the provided buffer or to an internally allocated buffer, if <code>pBuffer</code> is <code>NULL</code>. Callers providing their own buffer must ensure the buffer large enough to hold the inflated data for files deflated with Zstd or ZLIB. See <a class="el" href="group__reader.html#gaefcaf84425830ba095eb670a275dad34" title="Return the total size in bytes of the uncompressed data of a ktxTexture2.">ktxTexture2_GetDataSizeUncompressed()</a>.</p>
<p>The texture's levelIndex, dataSize, DFD and supercompressionScheme will all be updated after successful inflation to reflect the inflated data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a> object of interest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>pointer to the buffer in which to load the image data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufSize</td><td>size of the buffer pointed at by <code>pBuffer</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>KTX_SUCCESS on success, other KTX_* enum values on error.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KTX_INVALID_VALUE</td><td><code>This</code> is NULL. </td></tr>
    <tr><td class="paramname">KTX_INVALID_VALUE</td><td><code>bufSize</code> is less than the the image data size. </td></tr>
    <tr><td class="paramname">KTX_INVALID_OPERATION</td><td>The data has already been loaded or the <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a> was not created from a KTX source. </td></tr>
    <tr><td class="paramname">KTX_OUT_OF_MEMORY</td><td>Insufficient memory for the image data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade1ffc5d31c2f9b5f1e861b59e7619ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade1ffc5d31c2f9b5f1e861b59e7619ce">&#9670;&nbsp;</a></span>ktxTexture2_NeedsTranscoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ktx_bool_t ktxTexture2_NeedsTranscoding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture2.html">ktxTexture2</a> *&#160;</td>
          <td class="paramname"><em>This</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query if the images are in a transcodable format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> object of interest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga90cc33928a2dae962fb94b3fa2f6575d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90cc33928a2dae962fb94b3fa2f6575d">&#9670;&nbsp;</a></span>ktxTexture2_TranscodeBasis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture2_TranscodeBasis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture2.html">ktxTexture2</a> *&#160;</td>
          <td class="paramname"><em>This</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ktx_8h.html#a30cc58c576392303d9a5a54b57ef29b5">ktx_transcode_fmt_e</a>&#160;</td>
          <td class="paramname"><em>outputFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktx_transcode_flags&#160;</td>
          <td class="paramname"><em>transcodeFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transcode a KTX2 texture with BasisLZ/ETC1S or UASTC images. </p>
<p>If the texture contains BasisLZ supercompressed images, Inflates them from back to ETC1S then transcodes them to the specified block-compressed format. If the texture contains UASTC images, inflates them, if they have been supercompressed with zstd, then transcodes then to the specified format, The transcoded images replace the original images and the texture's fields including the DFD are modified to reflect the new format.</p>
<p>These types of textures must be transcoded to a desired target block-compressed format before they can be uploaded to a GPU via a graphics API.</p>
<p>The following block compressed transcode targets are available: <code>KTX_TTF_ETC1_RGB</code>, <code>KTX_TTF_ETC2_RGBA</code>, <code>KTX_TTF_BC1_RGB</code>, <code>KTX_TTF_BC3_RGBA</code>, <code>KTX_TTF_BC4_R</code>, <code>KTX_TTF_BC5_RG</code>, <code>KTX_TTF_BC7_RGBA</code>, <code><code>KTX_TTF_PVRTC1_4_RGB</code>,</code> <code>KTX_TTF_PVRTC1_4_RGBA</code>, <code>KTX_TTF_PVRTC2_4_RGB</code>, <code>KTX_TTF_PVRTC2_4_RGBA</code>, <code>KTX_TTF_ASTC_4x4_RGBA</code>, <code>KTX_TTF_ETC2_EAC_R11</code>, <code>KTX_TTF_ETC2_EAC_RG11</code>, <code>KTX_TTF_ETC</code> and <code>KTX_TTF_BC1_OR_3</code>.</p>
<p><code>KTX_TTF_ETC</code> automatically selects between <code>KTX_TTF_ETC1_RGB</code> and <code>KTX_TTF_ETC2_RGBA</code> according to whether an alpha channel is available. <code>KTX_TTF_BC1_OR_3</code> does likewise between <code>KTX_TTF_BC1_RGB</code> and <code>KTX_TTF_BC3_RGBA</code>. Note that if <code>KTX_TTF_PVRTC1_4_RGBA</code> or <code>KTX_TTF_PVRTC2_4_RGBA</code> is specified and there is no alpha channel <code>KTX_TTF_PVRTC1_4_RGB</code> or <code>KTX_TTF_PVRTC2_4_RGB</code> respectively will be selected.</p>
<p>Transcoding to ATC &amp; FXT1 formats is not supported by libktx as there are no equivalent Vulkan formats.</p>
<p>The following uncompressed transcode targets are also available: <code>KTX_TTF_RGBA32</code>, <code>KTX_TTF_RGB565</code>, KTX_TTF_BGR565 and KTX_TTF_RGBA4444.</p>
<p>The following <code>transcodeFlags</code> are available.</p>
<dl class="section see"><dt>See also</dt><dd>ktxtexture2_CompressBasis().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> object of interest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputFormat</td><td>a value from the ktx_texture_transcode_fmt_e enum specifying the target format. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transcodeFlags</td><td>bitfield of flags modifying the transcode operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>ktx_texture_decode_flags_e.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>KTX_SUCCESS on success, other KTX_* enum values on error.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KTX_FILE_DATA_ERROR</td><td>Supercompression global data is corrupted. </td></tr>
    <tr><td class="paramname">KTX_INVALID_OPERATION</td><td>The texture's format is not transcodable (not ETC1S/BasisLZ or UASTC). </td></tr>
    <tr><td class="paramname">KTX_INVALID_OPERATION</td><td>Supercompression global data is missing, i.e., the texture object is invalid. </td></tr>
    <tr><td class="paramname">KTX_INVALID_OPERATION</td><td>Image data is missing, i.e., the texture object is invalid. </td></tr>
    <tr><td class="paramname">KTX_INVALID_OPERATION</td><td><code>outputFormat</code> is PVRTC1 but the texture does does not have power-of-two dimensions. </td></tr>
    <tr><td class="paramname">KTX_INVALID_VALUE</td><td><code>outputFormat</code> is invalid. </td></tr>
    <tr><td class="paramname">KTX_TRANSCODE_FAILED</td><td>Something went wrong during transcoding. </td></tr>
    <tr><td class="paramname">KTX_UNSUPPORTED_FEATURE</td><td>KTX_TF_PVRTC_DECODE_TO_NEXT_POW2 was requested or the specified transcode target has not been included in the library being used. </td></tr>
    <tr><td class="paramname">KTX_OUT_OF_MEMORY</td><td>Not enough memory to carry out transcoding. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf1e401967a687b40cdf7bba11e72c2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1e401967a687b40cdf7bba11e72c2b4">&#9670;&nbsp;</a></span>ktxTexture_CreateFromMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture_CreateFromMemory </td>
          <td>(</td>
          <td class="paramtype">const ktx_uint8_t *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktx_size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structktxTexture.html#a1cce9de12eb3974a236becfd098bd057">ktxTextureCreateFlags</a>&#160;</td>
          <td class="paramname"><em>createFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structktxTexture.html">ktxTexture</a> **&#160;</td>
          <td class="paramname"><em>newTex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> or <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> from KTX-formatted data in memory according to the data contents. </p>
<p>See <a class="el" href="group__reader.html#ga1f289eb80601208b79561804d2ec0121">ktxTexture1_CreateFromMemory</a> or <a class="el" href="group__reader.html#ga6805a144f0bfd17b51d46fb28b0786a5">ktxTexture2_CreateFromMemory</a> for details. </p>

</div>
</div>
<a id="ga57a1ce0d3f2d66439463160d6ce9d2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57a1ce0d3f2d66439463160d6ce9d2d0">&#9670;&nbsp;</a></span>ktxTexture_CreateFromNamedFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture_CreateFromNamedFile </td>
          <td>(</td>
          <td class="paramtype">const char *const&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structktxTexture.html#a1cce9de12eb3974a236becfd098bd057">ktxTextureCreateFlags</a>&#160;</td>
          <td class="paramname"><em>createFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structktxTexture.html">ktxTexture</a> **&#160;</td>
          <td class="paramname"><em>newTex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> or <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> from a named KTX file according to the file contents. </p>
<p>See <a class="el" href="group__reader.html#ga0319d9a33d3ea78da2ef786205f2a956">ktxTexture1_CreateFromNamedFile</a> or <a class="el" href="group__reader.html#ga8680560274b31da6f3f07ee911055431">ktxTexture2_CreateFromNamedFile</a> for details. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="vkload_8cpp-example.html#a5">vkload.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga180d93562cc6af30c61adf8f6a8fd827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga180d93562cc6af30c61adf8f6a8fd827">&#9670;&nbsp;</a></span>ktxTexture_CreateFromStdioStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture_CreateFromStdioStream </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stdioStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structktxTexture.html#a1cce9de12eb3974a236becfd098bd057">ktxTextureCreateFlags</a>&#160;</td>
          <td class="paramname"><em>createFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structktxTexture.html">ktxTexture</a> **&#160;</td>
          <td class="paramname"><em>newTex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="structktxTexture1.html" title="Class representing a KTX version 1 format texture.">ktxTexture1</a> or <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> from a stdio stream according to the stream data. </p>
<p>See <a class="el" href="group__reader.html#ga4557b9714b41e7c575d295b65e19ed12">ktxTexture1_CreateFromStdioStream</a> or <a class="el" href="group__reader.html#gae9de7e23ffe3ae3aeed4cc95c61699e4">ktxTexture2_CreateFromStdioStream</a> for details. </p>

</div>
</div>
<a id="gaa8dfc7a981b69d26eab73c5405d7182b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8dfc7a981b69d26eab73c5405d7182b">&#9670;&nbsp;</a></span>ktxTexture_CreateFromStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture_CreateFromStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxStream.html">ktxStream</a> *&#160;</td>
          <td class="paramname"><em>pStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structktxTexture.html#a1cce9de12eb3974a236becfd098bd057">ktxTextureCreateFlags</a>&#160;</td>
          <td class="paramname"><em>createFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structktxTexture.html">ktxTexture</a> **&#160;</td>
          <td class="paramname"><em>newTex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a ktx1 or ktx2 texture according to the stream data. </p>
<p>See <a class="el" href="group__reader.html#ga2e9c9d8a1c02732c87db733d3449b337">ktxTexture1_CreateFromStream</a> or <a class="el" href="group__reader.html#ga1e865473d23f82fc22a16bb3eadf60ed">ktxTexture2_CreateFromStream</a> for details. </p>

</div>
</div>
<a id="gace44d98fa78b94c282016e7cf8a88b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace44d98fa78b94c282016e7cf8a88b7e">&#9670;&nbsp;</a></span>ktxTexture_GetData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ktx_uint8_t * ktxTexture_GetData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture.html">ktxTexture</a> *&#160;</td>
          <td class="paramname"><em>This</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the texture image data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a> object of interest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga553c3438e75628c6d7e2280989e539c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga553c3438e75628c6d7e2280989e539c4">&#9670;&nbsp;</a></span>ktxTexture_GetDataSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ktx_size_t ktxTexture_GetDataSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture.html">ktxTexture</a> *&#160;</td>
          <td class="paramname"><em>This</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the total size of the texture image data in bytes. </p>
<p>For a <a class="el" href="structktxTexture2.html" title="Class representing a KTX version 2 format texture.">ktxTexture2</a> with supercompressionScheme != KTX_SS_NONE this will return the deflated size of the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a> object of interest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga19d8786eea0e62ab55d945bff838d32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19d8786eea0e62ab55d945bff838d32c">&#9670;&nbsp;</a></span>ktxTexture_GetElementSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ktx_uint32_t ktxTexture_GetElementSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture.html">ktxTexture</a> *&#160;</td>
          <td class="paramname"><em>This</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size in bytes of an elements of a texture's images. </p>
<p>For uncompressed textures an element is one texel. For compressed textures it is one block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a> object of interest. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacf9e393ff766982ccb79ad915975971f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf9e393ff766982ccb79ad915975971f">&#9670;&nbsp;</a></span>ktxTexture_GetRowPitch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ktx_uint32_t ktxTexture_GetRowPitch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture.html">ktxTexture</a> *&#160;</td>
          <td class="paramname"><em>This</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ktx_uint32_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return pitch betweeb rows of a texture image level in bytes. </p>
<p>For uncompressed textures the pitch is the number of bytes between rows of texels. For compressed textures it is the number of bytes between rows of blocks. The value is padded to GL_UNPACK_ALIGNMENT, if necessary. For all currently known compressed formats padding will not be necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a> object of interest. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>level of interest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the row pitch in bytes. </dd></dl>

</div>
</div>
<a id="gae7c4b8bbe26379f2076f93050c0673c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7c4b8bbe26379f2076f93050c0673c1">&#9670;&nbsp;</a></span>ktxTexture_IterateLevelFaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ktx_8h.html#ad2efa40e38ebae48371375db92d34eaa">KTX_error_code</a> ktxTexture_IterateLevelFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structktxTexture.html">ktxTexture</a> *&#160;</td>
          <td class="paramname"><em>This</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structktxTexture.html#aca6d87118e724ac77f17e0576e191513">PFNKTXITERCB</a>&#160;</td>
          <td class="paramname"><em>iterCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over the levels or faces in a <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a> object. </p>
<p>Blocks of image data are passed to an application-supplied callback function. This is not a strict per-image iteration. Rather it reflects how OpenGL needs the images. For most textures the block of data includes all images of a mip level which implies all layers of an array. However, for non-array cube map textures the block is a single face of the mip level, i.e the callback is called once for each face.</p>
<p>This function works even if <code>This-&gt;pData</code> == 0 so it can be used to obtain offsets and sizes for each level by callers who have loaded the data externally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">This</td><td>pointer to the <a class="el" href="structktxTexture.html" title="Base class representing a texture.">ktxTexture</a> object of interest. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iterCb</td><td>the address of a callback function which is called with the data for each image block. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">userdata</td><td>the address of application-specific data which is passed to the callback along with the image data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>KTX_SUCCESS on success, other KTX_* enum values on error. The following are returned directly by this function. <code>iterCb</code> may return these for other causes or may return additional errors.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">KTX_FILE_DATA_ERROR</td><td>Mip level sizes are increasing not decreasing </td></tr>
    <tr><td class="paramname">KTX_INVALID_VALUE</td><td><code>This</code> is <code>NULL</code> or <code>iterCb</code> is <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="glloader_8c-example.html#a16">glloader.c</a>.</dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Mar 20 2024 17:41:33 for libktx Reference by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
